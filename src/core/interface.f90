!--------------------------------------------------------------------------------------------------
! MODULE: interface_mod
!> @author Marin Sapunar, Ruđer Bošković Institute
!> @date January 2020
!--------------------------------------------------------------------------------------------------
module interface_mod
    use global_defs
    use control_var
    implicit none

    private
    public :: run_qm
    public :: run_mm


contains


    !----------------------------------------------------------------------------------------------
    ! SUBROUTINE: Interface_QMRun
    !
    ! DESCRIPTION:
    !> @brief Run a single point QM calculation.
    !> @details
    !! An external program is called which reads files created by Interface_WriteStatus and runs a
    !! single point calculation.
    !! The external program should always output:
    !!   qmen   - Containing energies and oscillator strengths of electronic states.
    !!   qmgrad - Containing the gradient of the selected electronic state.
    !! to calculate couplings there are two options:
    !!   qmoverlap - For the overlap matrix. This is usually generated by another external program.
    !!   qmnadvec - For the coupling vectors.
    !----------------------------------------------------------------------------------------------
    subroutine run_qm(t, hop)
        use system_var, only : trajtype
        use matrix_mod, only : unit_mat
        type(trajtype), intent(inout) :: t
        logical :: hop
        integer :: cunit, i, d1, d2
        logical :: check1, check2

        if ((t%step > 0) .and. (.not. hop)) then
            call system('rm -rf prevstep')
            call system('cp -r '//ctrl%qmdir//' prevstep')
        end if

        open(newunit=cunit, file='cstep', action='write')
        write(cunit, '(i4.4)') t%step
        close(cunit)

        open(newunit=cunit, file='qm_geom', action='write')
        do i = 1, t%qnatom
            write(cunit, *) t%geom(:, t%qind(i))
        end do
        close(cunit)

        open(newunit=cunit, file='qm_state', action='write')
        write(cunit, *) t%cstate, t%nstate
        close(cunit)

        if (ctrl%mm) then
            open(newunit=cunit, file='mm_geom', action='write')
            do i = 1, t%mnatom
                write(cunit, *) t%geom(:, t%mind(i))
            end do
            close(cunit)
        end if

        ! Call interface.
        call system('rm qm_energy qm_grad qm_oscill qm_olap 2> /dev/null')
        call system(ctrl%qprog)

        ! Check if energy and gradient files were created.
        inquire(file='qm_energy', exist=check1)
        if (.not. check1) write(stderr, *) 'Error, qm_energy file not found after QM calculation.'
        inquire(file='qm_grad', exist=check2)
        if (.not. check2) write(stderr, *) 'Error, qm_grad file not found after QM calculation.'
        if ((.not. check1) .or. (.not. check2)) then
            call system('rm -rf qmdir_error')
            call system('cp -r '//ctrl%qmdir//' qmdir_error')
            stop
        end if

        t%qe = 0.0_dp
        open(newunit=cunit, file='qm_energy', action='read')
        read(cunit, *) t%qe(1:t%nstate)
        close(cunit)
        
        t%grad = 0.0_dp
        open(newunit=cunit, file='qm_grad', action='read')
        do i = 1, t%qnatom
            read(cunit, *) t%grad(:, t%qind(i))
        end do
        close(cunit)

        if (ctrl%oscill) then
            t%qo = 0.0_dp
            open(newunit=cunit, file='qm_oscill', action='read')
            read(cunit, *) t%qo(1:t%nstate-1)
            close(cunit)
        end if

        if ((ctrl%tdc_type == 1) .and. (t%step /= 0)) then
            call system(ctrl%oprog)
            t%olap = unit_mat(t%max_nstate)
            open(newunit=cunit, file='qm_olap', action='read')
            read(cunit, *) d1, d2
            do i = 1, min(d1, d2)
                read(cunit, *) t%olap(i, 1:min(d1, d2))
            end do
            close(cunit)

            do i = 1, t%max_nstate
                if (.not. ctrl%couple(i)) then
                    t%olap(i, :) = 0.0_dp
                    t%olap(:, i) = 0.0_dp
                end if
            end do
        end if
    end subroutine run_qm


    !----------------------------------------------------------------------------------------------
    ! SUBROUTINE: Interface_MMRun
    !----------------------------------------------------------------------------------------------
    subroutine run_mm(t)
        use system_var, only : trajtype
        type(trajtype), intent(inout) :: t
        integer :: i, cunit
        logical :: check1, check2, check3

        call nad_interface_write_atoms(t%natom, t%qnatom, t%mnatom, t%qind, t%mind, t%sym, t%geom,&
        &                              t%velo, ctrl%pbc, t%pbcbox)

        ! Call QM program.
        call system('rm -f mm_energy mm_grad mm_pbc')
        call system(ctrl%mprog)

        ! Check if energy and gradient files were created.
        inquire(file='mm_energy', exist=check1)
        if (.not. check1) write(stderr, *) 'Error, mm_energy file not found after MM calculation.'
        inquire(file='mm_grad', exist=check2)
        if (.not. check2) write(stderr, *) 'Error, mm_grad file not found after MM calculation.'
        check3 = .true.
        if (ctrl%pbc) then
            inquire(file='mm_pbc', exist=check3)
            if (.not. check3) write(stderr, *) 'Error, mm_pbc file not found after MM calculation.'
        end if
        if ((.not. check1) .or. (.not. check2) .or. (.not. check3)) then
            call system('rm -rf mmdir_error')
            call system('cp -r '//ctrl%qmdir//' mmdir_error')
            stop
        end if

        open(newunit=cunit, file='mm_energy', action='read')
        read(cunit, *) t%me
        close(cunit)
        
        open(newunit=cunit, file='mm_grad', action='read')
        do i = 1, t%natom
            read(cunit, *) t%grad(:, i)
        end do
        close(cunit)

        open(newunit=cunit, file='mm_pbc', action='read')
        read(cunit, *) t%pbcbox
        close(cunit)

        t%me(1) = t%me(1) - eelp(t%geom(:, t%qind), t%geom(:, t%mind), t%chrg(t%qind),             &
        &         t%chrg(t%mind), ctrl%mmcut)
    end subroutine run_mm


    subroutine nad_interface_write_atoms(nat, qnat, mnat, qind, mind, sym, geo, vel, pbc, box)
        integer, intent(in) :: nat, qnat, mnat
        integer, intent(in) :: qind(:), mind(:)
        character(len=2), intent(in) :: sym(:)
        real(dp), intent(in) :: geo(:, :), vel(:, :)
        logical, intent(in) :: pbc
        real(dp), intent(in) :: box(6)
        character(len=*), parameter :: ifmt = '(1000(i0,1x))'
        character(len=*), parameter :: atomfmt = '(1x,a2,2x,1000e24.16)'
        character(len=*), parameter :: relfmt = '(1000(e24.16,2x))'
        integer :: ounit, i

        open(newunit=ounit, file='mm_data', action='write')
        write(ounit, *) nat, qnat, mnat
        write(ounit, ifmt) qind
        write(ounit, ifmt) mind
        do i = 1, nat
            write(ounit, atomfmt) sym(i), geo(:, i), vel(:, i)
        end do
        if (pbc) write(ounit, relfmt) box
        close(ounit)
    end subroutine nad_interface_write_atoms


    !----------------------------------------------------------------------------------------------
    ! FUNCTION: EElP
    !
    ! DESCRIPTION:
    !> @brief Calculate the electrostatic potential energy between two sets of point charges.
    !> @details
    !! Optionally, a cutoff distance can be passed to the function. If present, interactions
    !! between pairs of charges whose distance is greater than the cutoff distance will not be
    !! added to the final energy.
    !----------------------------------------------------------------------------------------------
    pure function eelp(geom1, geom2, q1, q2, cutoff) result (en)
        real(dp), intent(in) :: geom1(:, :)
        real(dp), intent(in) :: geom2(:, :)
        real(dp), intent(in) :: q1(:)
        real(dp), intent(in) :: q2(:)
        real(dp), optional, intent(in) :: cutoff
        real(dp) :: en
        integer :: i
        integer :: j
        real(dp) :: dxyz(size(geom1, 1))
        real(dp) :: d

        en = 0.0_dp
        do i = 1, size(q1)
            do j = 1, size(q2)
                dxyz = geom1(:, i) - geom2(:, j)
                d = sqrt(dot_product(dxyz, dxyz))
                if (present(cutoff)) then
                    if (d > cutoff) cycle
                end if
                en = en + q1(i) * q2(j) / d
            end do
        end do
    end function eelp

end module interface_mod
